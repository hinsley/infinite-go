<!DOCTYPE html>
<html>
    <head>
        <title>Infinite Go</title>
        <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='styles/main.css') }}">
        <link rel="icon" type="image/png" href="{{ url_for('static', filename='images/favicon.png') }}">
        <script src="{{ url_for('static', filename='scripts/refSort.js') }}"></script>
    </head>
    <body>
        <h1>Infinite Go</h1>
        <h3 style="font-style: italic;">
            {% if username is none %}
                <a href="{{ url_for('register') }}">Register</a> | <a href="{{ url_for('login') }}">Log In</a>
            {% else %}
                Logged in as {{ username }}. You have {{ score }} stone{{ "s" if score != "1" }}. | <a href="{{ url_for('logout') }}">Log Out</a>
            {% endif %}

            </h3>
            <div id="goban-container">
                <canvas id="goban" width="650" height="650"></canvas>
            </div>
            <div id="stone-tooltip" class="stone-tooltip" aria-hidden="true"></div>

            <div id="cursor-info">
                X: {{ cursor[0] }}, Y: {{ cursor[1] }}
            </div>
            
            <div id="pending-countdown"></div>

            {% if username is not none %}
                <br>
                
                <button id="placeStone">Place stone</button>
                <button id="cyclePending">Cycle pending stones</button>
                <script src="{{ url_for('static', filename='scripts/new_pending_poll.js') }}"></script>
                <script>newPendingPoll('{{ url_for('new_pending_poll', player=session["user"], polling_start_time=polling_start_time) | safe }}');</script>
            {% endif %}
            <div id="color-legend"></div>

            <h4>
                <a href="https://github.com/hinsley/infinite-go">GitHub</a> | <a href="https://discord.gg/dzhBtPZbEz">Discord</a>
            </h4>

            <script src="{{ url_for('static', filename='scripts/color_code.js') }}"></script>
            <script src="{{ url_for('static', filename='scripts/render_goban_canvas.js') }}"></script>
            <script>
                // Make stones data reusable across features
                const stonesData = {{ stones | tojson }};
                const currentPlayer = {% if username is not none %} "{{ username }}" {% else %} null {% endif %};
                
                // Selection state
                let selectedX = Number({{ cursor[0] }});
                let selectedY = Number({{ cursor[1] }});
                
                // Initialize canvas draw loop and selected cell highlight
                drawLoop(stonesData, currentPlayer);
                if (typeof setSelectedCell === 'function') {
                    setSelectedCell(selectedX, selectedY);
                }

                function updateUrl(x, y) {
                    const newUrl = `${location.pathname}?x=${x}&y=${y}`;
                    history.replaceState({}, '', newUrl);
                }

                function updateCursorInfo(x, y) {
                    const el = document.getElementById('cursor-info');
                    if (el) el.textContent = `X: ${x}, Y: ${y}`;
                }

                function localRegionStones(allStones, cx, cy) {
                    const out = {};
                    Object.keys(allStones).forEach((key) => {
                        const parts = key.split(" ");
                        const sx = parseInt(parts[0], 10);
                        const sy = parseInt(parts[1], 10);
                        if (Math.abs(sx - cx) <= 6 && Math.abs(sy - cy) <= 6) {
                            out[key] = allStones[key];
                        }
                    });
                    return out;
                }

                function updatePlaceStoneDisabled(x, y) {
                    const btn = document.getElementById('placeStone');
                    if (!btn) return;
                    const regionStones = localRegionStones(stonesData, x, y);
                    let validMove = Object.keys(regionStones).length > 0;
                    Object.keys(regionStones).forEach((coords) => {
                        const s = regionStones[coords];
                        if (
                            `${x} ${y}` === coords ||
                            (s["status"] === "Locked" && s["player_name"] === currentPlayer) ||
                            (s["status"] === "Pending" && s["player_name"] !== currentPlayer)
                        ) {
                            validMove = false;
                        }
                    });
                    if (!validMove) {
                        btn.setAttribute('disabled', true);
                    } else {
                        btn.removeAttribute('disabled');
                    }
                }

                let countdownIntervalId = null;
                function updatePendingCountdown(x, y) {
                    const el = document.getElementById('pending-countdown');
                    if (!el) return;
                    if (countdownIntervalId !== null) {
                        clearInterval(countdownIntervalId);
                        countdownIntervalId = null;
                    }
                    const key = `${x} ${y}`;
                    const stone = stonesData[key];
                    if (!stone || stone["status"] !== 'Pending') {
                        el.textContent = '';
                        return;
                    }
                    const pendingSince = Number(stone["last_status_change_time"]);
                    function epoch() { return Date.now() / 1000; }
                    function tick() {
                        const remaining = Math.floor(pendingSince + 86400 - epoch());
                        if (remaining > 0) {
                            const sec = remaining % 60;
                            const min = Math.floor((remaining % 3600) / 60);
                            const hrs = Math.floor(remaining / 3600);
                            el.textContent = `${hrs.toString().padStart(2,'0')}:${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')} remaining until stone is unlocked.`;
                        } else {
                            el.textContent = 'Stone unlocked; refresh to update.';
                        }
                    }
                    tick();
                    countdownIntervalId = setInterval(tick, 1000);
                }

                function applySelection(x, y) {
                    selectedX = x; selectedY = y;
                    if (typeof setSelectedCell === 'function') setSelectedCell(x, y);
                    updateUrl(x, y);
                    updateCursorInfo(x, y);
                    updatePlaceStoneDisabled(x, y);
                    updatePendingCountdown(x, y);
                }

                // Initial UI state based on server-provided cursor
                applySelection(selectedX, selectedY);

                // Click-to-select: highlight cell and update URL without reload
                (function() {
                    const canvasEl = document.getElementById('goban');
                    canvasEl.addEventListener('click', function(e) {
                        const world = canvas2World(mouseX(e), mouseY(e));
                        const selX = Math.round(world[0]);
                        const selY = Math.round(world[1]);
                        applySelection(selX, selY);
                    });
                })();

                // Build color legend (same method as index) using local region stones near initial cursor
                (function() {
                    const cxNum = Number(selectedX);
                    const cyNum = Number(selectedY);
                    const regionStones = localRegionStones(stonesData, cxNum, cyNum);
                    var player_scores = [];
                    var player_names = [];
                    Object.values(regionStones).forEach((stone) => {
                        if (!player_names.includes(stone["player_name"])) {
                            player_scores.push(stone["player_score"]);
                            player_names.push(stone["player_name"]);
                        }
                    });
                    // Assign colors by relative player scores.
                    player_names = refSort(player_names, player_scores).reverse();
                    player_scores.sort((a, b) => b - a);
                    for (var i = 0; i < player_names.length; i++) {
                        var legendEntry = document.createElement("div");
                        legendEntry.setAttribute("class", "legend-entry");
                        var colorIcon = document.createElement("div");
                        colorIcon.setAttribute("class", "color-icon");
                        colorIcon.setAttribute("style", "background-color: " + color_code[i] + ";");
                        legendEntry.appendChild(colorIcon);
                        legendEntry.append(" " + player_names[i] + " (" + Number(player_scores[i]).toLocaleString() + ")");
                        document.getElementById("color-legend").appendChild(legendEntry);
                    }
                })();

                // Wire up buttons
                (function() {
                    const placeBtn = document.getElementById('placeStone');
                    if (placeBtn) {
                        placeBtn.addEventListener('click', function() {
                            location = `/go?x=${selectedX}&y=${selectedY}`;
                        });
                    }
                    const cycleBtn = document.getElementById('cyclePending');
                    if (cycleBtn) {
                        cycleBtn.addEventListener('click', function() {
                            // Compute next pending selection for current player without reload
                            if (!currentPlayer) return;
                            const pending = [];
                            Object.keys(stonesData).forEach((key) => {
                                const s = stonesData[key];
                                if (s["player_name"] === currentPlayer && s["status"] === 'Pending') {
                                    const parts = key.split(' ');
                                    pending.push({
                                        x: parseInt(parts[0], 10),
                                        y: parseInt(parts[1], 10),
                                        since: Number(s["last_status_change_time"]) || 0
                                    });
                                }
                            });
                            if (pending.length === 0) {
                                // No pending stones; keep selection
                                return;
                            }
                            // Determine base time from current selection if it's your pending
                            let base = 0;
                            const curKey = `${selectedX} ${selectedY}`;
                            const curStone = stonesData[curKey];
                            if (curStone && curStone["player_name"] === currentPlayer && curStone["status"] === 'Pending') {
                                base = Number(curStone["last_status_change_time"]) || 0;
                            }
                            const younger = pending.filter(p => p.since > base).sort((a,b)=>a.since-b.since);
                            let next;
                            if (younger.length > 0) {
                                next = younger[0];
                            } else {
                                // Oldest overall
                                next = pending.sort((a,b)=>a.since-b.since)[0];
                            }
                            applySelection(next.x, next.y);
                        });
                    }
                })();
            </script>
    </body>
</html>