<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
        <title>Infinite Go</title>
        <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='styles/main.css') }}">
        <link rel="icon" type="image/png" href="{{ url_for('static', filename='images/favicon.png') }}">
        <script src="{{ url_for('static', filename='scripts/refSort.js') }}"></script>
    </head>
    <body>
        <h1>Infinite Go</h1>
        <h3 style="font-style: italic;">
            {% if username is none %}
                <a href="{{ url_for('register') }}">Register</a> | <a href="{{ url_for('login') }}">Log In</a>
            {% else %}
                Logged in as {{ username }}. You have {{ score }} stone{{ "s" if score != "1" }}. | <a href="{{ url_for('logout') }}">Log Out</a>
            {% endif %}

            </h3>
            <div id="goban-container">
                <canvas id="goban" width="650" height="650"></canvas>
            </div>
            <div id="stone-tooltip" class="stone-tooltip" aria-hidden="true"></div>

            <div id="cursor-info">
                X: {{ cursor[0] }}, Y: {{ cursor[1] }}
            </div>
            
            <div id="pending-countdown"></div>

            {% if username is not none %}
                <br>
                
                <button id="placeStone">Place stone</button>
                <button id="cyclePending">Cycle pending stones</button>
                <script src="{{ url_for('static', filename='scripts/new_pending_poll.js') }}"></script>
                <script>newPendingPoll('{{ url_for('new_pending_poll', player=session["user"], polling_start_time=polling_start_time) | safe }}');</script>
            {% endif %}
            <div id="color-legend"></div>

            <h4>
                <a href="https://github.com/hinsley/infinite-go">GitHub</a> | <a href="https://discord.gg/dzhBtPZbEz">Discord</a>
            </h4>

            <script src="{{ url_for('static', filename='scripts/color_code.js') }}"></script>
            <script>window.VIEWPORT_RESOLUTION_SCALE = 2;</script>
            <script src="{{ url_for('static', filename='scripts/render_goban_canvas.js') }}"></script>
            <script>
                // Make stones data reusable across features
                const stonesData = {{ stones | tojson }};
                // Expose for other modules (e.g., canvas tooltip refresher)
                window.stonesData = stonesData;
                const currentPlayer = {% if username is not none %} "{{ username }}" {% else %} null {% endif %};
                
                /**
                 * PendingStonesIndex: cache for efficiently managing Pending stones.
                 * - Maintains a Map keyed by "x y" -> { x, y, since } for stones with status === 'Pending'.
                 * - Supports quick retrieval of the next-to-unlock stones and fast updates on placements/captures/unlocks.
                 * - Must ALWAYS be kept in sync with `stonesData` when stones are added/removed or statuses change.
                 */
                const PendingStonesIndex = (() => {
                    const byKey = new Map();
                    function keyOf(x, y) { return `${x} ${y}`; }
                    function add(x, y, since) { byKey.set(keyOf(x,y), { x, y, since: Number(since)||0 }); }
                    function remove(x, y) { byKey.delete(keyOf(x,y)); }
                    function has(x, y) { return byKey.has(keyOf(x,y)); }
                    function get(x, y) { return byKey.get(keyOf(x,y)) || null; }
                    function rebuildFrom(stones) {
                        byKey.clear();
                        Object.keys(stones).forEach((k) => {
                            const s = stones[k];
                            if (s && s.status === 'Pending') {
                                const parts = k.split(' ');
                                add(parseInt(parts[0],10), parseInt(parts[1],10), s.last_status_change_time);
                            }
                        });
                    }
                    function forEach(fn) { byKey.forEach((v)=>fn(v)); }
                    function size() { return byKey.size; }
                    function nextUnlocking(limit=10) {
                        return Array.from(byKey.values()).sort((a,b)=>a.since-b.since).slice(0, limit);
                    }
                    return { add, remove, has, get, rebuildFrom, forEach, size, nextUnlocking };
                })();

                // Selection state
                let selectedX = Number({{ cursor[0] }});
                let selectedY = Number({{ cursor[1] }});
                
                // Initialize canvas draw loop and selected cell highlight
drawLoop(stonesData, currentPlayer);
if (typeof setSelectedCell === 'function') {
    setSelectedCell(selectedX, selectedY);
}

// On first load, if a selection is present in URL/server, pan to it and reset zoom to initial level
(function() {
    const params = new URLSearchParams(location.search);
    const hasX = params.has('x');
    const hasY = params.has('y');
    if (hasX && hasY) {
        const ux = Number(params.get('x'));
        const uy = Number(params.get('y'));
        if (Number.isFinite(ux) && Number.isFinite(uy)) {
            if (typeof centerAndResetZoom === 'function') {
                centerAndResetZoom(ux, uy);
            } else if (typeof centerOnWorldCoord === 'function') {
                centerOnWorldCoord(ux, uy);
            }
        }
    }
})();
 
                 function updateUrl(x, y) {
                     const newUrl = `${location.pathname}?x=${x}&y=${y}`;
                     history.replaceState({}, '', newUrl);
                 }
 
                 function updateCursorInfo(x, y) {
                     const el = document.getElementById('cursor-info');
                     if (el) el.textContent = `X: ${x}, Y: ${y}`;
                 }
 
                function getStoneKey(x, y) { return `${x} ${y}`; }
                function hasStoneAt(x, y) { return Object.prototype.hasOwnProperty.call(stonesData, getStoneKey(x, y)); }
                function getStoneAt(x, y) { return stonesData[getStoneKey(x, y)] || null; }
                function setStoneAt(x, y, stoneObj) { stonesData[getStoneKey(x, y)] = stoneObj; }
                function removeStoneAt(x, y) { delete stonesData[getStoneKey(x, y)]; }
                function neighborsOf(x, y) { return [ [x-1, y], [x, y+1], [x+1, y], [x, y-1] ]; }

                // Build initial PendingStonesIndex from server data
                PendingStonesIndex.rebuildFrom(stonesData);

                // Live per-player global stone counts; initialize from server-provided player_score
                const playerScores = new Map();
                (function initPlayerScores() {
                    Object.keys(stonesData).forEach((key) => {
                        const s = stonesData[key];
                        const name = String(s["player_name"]);
                        if (!playerScores.has(name)) {
                            // `player_score` provided is the global count for that player
                            playerScores.set(name, Number(s["player_score"]) || 0);
                        }
                    });
                })();

                function setAllStonesScoreForPlayer(playerName, newScore) {
                    Object.keys(stonesData).forEach((key) => {
                        const s = stonesData[key];
                        if (String(s["player_name"]) === playerName) {
                            s["player_score"] = newScore;
                        }
                    });
                }

                function updatePlayerScore(playerName, delta) {
                    if (!playerName || !Number.isFinite(delta) || delta === 0) return;
                    const cur = playerScores.get(playerName) ?? 0;
                    const next = Math.max(0, cur + delta);
                    playerScores.set(playerName, next);
                    setAllStonesScoreForPlayer(playerName, next);
                }

                function localRegionStones(allStones, cx, cy) {
                    const out = {};
                    Object.keys(allStones).forEach((key) => {
                        const parts = key.split(" ");
                        const sx = parseInt(parts[0], 10);
                        const sy = parseInt(parts[1], 10);
                        if (Math.abs(sx - cx) <= 6 && Math.abs(sy - cy) <= 6) {
                            out[key] = allStones[key];
                        }
                    });
                    return out;
                }
 
                 function updatePlaceStoneDisabled(x, y) {
                     const btn = document.getElementById('placeStone');
                     if (!btn) return;
                     const regionStones = localRegionStones(stonesData, x, y);
                     let validMove = Object.keys(regionStones).length > 0;
                     Object.keys(regionStones).forEach((coords) => {
                         const s = regionStones[coords];
                         if (
                             `${x} ${y}` === coords ||
                             (s["status"] === "Locked" && s["player_name"] === currentPlayer) ||
                             (s["status"] === "Pending" && s["player_name"] !== currentPlayer)
                         ) {
                             validMove = false;
                         }
                     });
                     if (!validMove) {
                         btn.setAttribute('disabled', true);
                     } else {
                         btn.removeAttribute('disabled');
                     }
                     return validMove;
                 }
 
                 let countdownIntervalId = null;
                 function updatePendingCountdown(x, y) {
                     const el = document.getElementById('pending-countdown');
                     if (!el) return;
                     if (countdownIntervalId !== null) {
                         clearInterval(countdownIntervalId);
                         countdownIntervalId = null;
                     }
                     const key = `${x} ${y}`;
                     const stone = stonesData[key];
                     if (!stone || stone["status"] !== 'Pending') {
                         el.textContent = '';
                         return;
                     }
                     const pendingSince = Number(stone["last_status_change_time"]);
                     function epoch() { return Date.now() / 1000; }
                     function tick() {
                         const remaining = Math.floor(pendingSince + 86400 - epoch());
                         if (remaining > 0) {
                             const sec = remaining % 60;
                             const min = Math.floor((remaining % 3600) / 60);
                             const hrs = Math.floor(remaining / 3600);
                             el.textContent = `${hrs.toString().padStart(2,'0')}:${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')} remaining until stone is unlocked.`;
                         } else {
                             el.textContent = 'Stone unlocked; refresh to update.';
                         }
                     }
                     tick();
                     countdownIntervalId = setInterval(tick, 1000);
                 }
 
                function evolveStatusesAround(x, y) {
                    const region = localRegionStones(stonesData, x, y);
                    const now = Date.now() / 1000;
                    Object.keys(region).forEach((coords) => {
                        const s = region[coords];
                        const prev = s["status"];
                        let next = prev;
                        if (prev === 'Locked') next = 'Pending';
                        else if (prev === 'Pending') next = 'Unlocked';
                        if (next !== prev) {
                            s["status"] = next;
                            s["last_status_change_time"] = now;
                            stonesData[coords] = s;
                            // Maintain PendingStonesIndex
                            const parts = coords.split(' ');
                            const cx = parseInt(parts[0],10), cy = parseInt(parts[1],10);
                            if (next === 'Pending') {
                                PendingStonesIndex.add(cx, cy, now);
                            } else {
                                PendingStonesIndex.remove(cx, cy);
                            }
                        }
                    });
                }

                function findGroupAndCaptured(originX, originY) {
                    const origin = getStoneAt(originX, originY);
                    if (!origin) return { group: new Map(), captured: false };
                    const player = origin["player_name"];
                    const group = new Map();
                    group.set(getStoneKey(originX, originY), [originX, originY]);
                    const queue = neighborsOf(originX, originY);
                    const visited = new Set(group.keys());
                    while (queue.length > 0) {
                        const [nx, ny] = queue.pop();
                        const key = getStoneKey(nx, ny);
                        if (visited.has(key)) continue;
                        visited.add(key);
                        const s = getStoneAt(nx, ny);
                        if (!s) {
                            // liberty found
                            return { group, captured: false };
                        }
                        if (s["player_name"] === player) {
                            group.set(key, [nx, ny]);
                            const nextAdj = neighborsOf(nx, ny);
                            for (let k = 0; k < nextAdj.length; k++) queue.push(nextAdj[k]);
                        }
                    }
                    // no liberties
                    return { group, captured: true };
                }

                function resolveCapturesAfterPlacement(px, py) {
                    // Stage 1: check groups adjacent to the placed point; collect per-player removals
                    const adj = neighborsOf(px, py);
                    let removedCoords = [];
                    const toCheck = [];
                    for (let i = 0; i < adj.length; i++) {
                        const [ax, ay] = adj[i];
                        const s = getStoneAt(ax, ay);
                        if (!s) continue;
                        toCheck.push([ax, ay]);
                    }
                    const removedSet = new Set();
                    const removedByPlayer = new Map(); // name -> count
                    for (let i = 0; i < toCheck.length; i++) {
                        const [cx, cy] = toCheck[i];
                        const res = findGroupAndCaptured(cx, cy);
                        if (res.captured) {
                            for (const [key, coords] of res.group) {
                                if (removedSet.has(key)) continue;
                                removedSet.add(key);
                                const s = getStoneAt(coords[0], coords[1]);
                                if (s) {
                                    const pname = String(s["player_name"]);
                                    removedByPlayer.set(pname, (removedByPlayer.get(pname) || 0) + 1);
                                    // Keep PendingStonesIndex in sync when captured
                                    if (s.status === 'Pending') {
                                        PendingStonesIndex.remove(coords[0], coords[1]);
                                    }
                                }
                                removedCoords.push(coords);
                            }
                        }
                    }
                    if (removedCoords.length > 0) {
                        for (let i = 0; i < removedCoords.length; i++) {
                            const [rx, ry] = removedCoords[i];
                            removeStoneAt(rx, ry);
                        }
                        return { removedCoords, removedByPlayer, suicideRemoved: 0 };
                    }
                    // Stage 2: suicide check on the placed stone's group
                    const selfRes = findGroupAndCaptured(px, py);
                    if (selfRes.captured) {
                        let count = 0;
                        for (const [, coords] of selfRes.group) {
                            // Sync index on suicide removal (check before deletion)
                            const removedStone = getStoneAt(coords[0], coords[1]);
                            if (removedStone && removedStone.status === 'Pending') {
                                PendingStonesIndex.remove(coords[0], coords[1]);
                            }
                            removeStoneAt(coords[0], coords[1]);
                            count += 1;
                        }
                        return { removedCoords: [], removedByPlayer: new Map(), suicideRemoved: count };
                    }
                    return { removedCoords: [], removedByPlayer: new Map(), suicideRemoved: 0 };
                }

                function updateHeaderUserScoreTo(value) {
                    if (!currentPlayer) return;
                    const h3 = document.querySelector('h3');
                    if (!h3) return;
                    const html = h3.innerHTML;
                    if (!/You have\s+([0-9,]+)/.test(html)) return;
                    const nextStr = Number(value).toLocaleString();
                    h3.innerHTML = html.replace(/You have\s+([0-9,]+)/, `You have ${nextStr}`);
                }

                function updateUserScoreBy(delta) {
                    if (!currentPlayer || delta === 0) return;
                    const cur = playerScores.get(currentPlayer) ?? 0;
                    updatePlayerScore(currentPlayer, delta);
                    updateHeaderUserScoreTo(cur + delta);
                }
 
                // Resolve the display color for a given player using the same mapping as the board
                function getColorForPlayer(playerName) {
                    try {
                        if (typeof playerColorMap !== 'object' || playerColorMap === null) {
                            if (typeof buildPlayerColorMap === 'function') {
                                // Build the global mapping once from all stones
                                playerColorMap = buildPlayerColorMap(stonesData, currentPlayer);
                            } else {
                                playerColorMap = {};
                            }
                        }
                    } catch (e) {
                        playerColorMap = playerColorMap || {};
                    }
                    if (currentPlayer && playerName === currentPlayer) return '#000000';
                    // Fallback to white if player not present in mapping
                    return (playerColorMap && playerColorMap[playerName]) ? playerColorMap[playerName] : '#FFFFFF';
                }

                function rebuildLeaderboard(x, y) {
                    const container = document.getElementById('color-legend');
                    if (!container) return;
                    // Clear existing
                    while (container.firstChild) container.removeChild(container.firstChild);
                    if (typeof x !== 'number' || typeof y !== 'number' || Number.isNaN(x) || Number.isNaN(y)) {
                        return; // no selection -> empty leaderboard
                    }
                    const region = localRegionStones(stonesData, x, y);
                    // Collect unique player names present in region
                    const names = [];
                    Object.keys(region).forEach((k) => {
                        const pname = String(region[k]["player_name"]);
                        if (!names.includes(pname)) names.push(pname);
                    });
                    if (names.length === 0) return;
                    // Prepare arrays for sorting by global score desc
                    const scores = names.map(n => playerScores.get(n) ?? 0);
                    const sortedNames = refSort(names.slice(), scores).reverse();
                    const sortedScores = scores.slice().sort((a,b)=>b-a);
                    for (let i = 0; i < sortedNames.length; i++) {
                        const entry = document.createElement('div');
                        entry.setAttribute('class', 'legend-entry');
                        const colorIcon = document.createElement('div');
                        colorIcon.setAttribute('class', 'color-icon');
                        const colorHex = getColorForPlayer(sortedNames[i]);
                        colorIcon.setAttribute('style', `background-color: ${colorHex};`);
                        entry.appendChild(colorIcon);
                        const scoreVal = Number(sortedScores[i]).toLocaleString();
                        entry.append(` ${sortedNames[i]} (${scoreVal})`);
                        container.appendChild(entry);
                    }
                }

                function applySelection(x, y) {
                    selectedX = x; selectedY = y;
                    if (typeof setSelectedCell === 'function') setSelectedCell(x, y);
                    updateUrl(x, y);
                    updateCursorInfo(x, y);
                    updatePlaceStoneDisabled(x, y);
                    updatePendingCountdown(x, y);
                    rebuildLeaderboard(x, y);
                }
                window.applySelection = applySelection;
 
                 // Initial UI state based on server-provided cursor
                 applySelection(selectedX, selectedY);
 
                 // Click-to-select: highlight cell and update URL without reload
                 (function() {
                     const canvasEl = document.getElementById('goban');
                     canvasEl.addEventListener('click', function(e) {
                         // Ignore click if it immediately follows a drag/pan
                         if (window.suppressNextClickSelection) {
                             window.suppressNextClickSelection = false;
                             return;
                         }
                         const world = canvas2World(mouseX(e), mouseY(e));
                         const selX = Math.round(world[0]);
                         const selY = Math.round(world[1]);
                         applySelection(selX, selY);
                     });
                 })();
 
                 // Build color legend (leaderboard) for the active 13x13 area and keep it live
                 rebuildLeaderboard(selectedX, selectedY);
 
                 // Wire up buttons
                 (function() {
                     const placeBtn = document.getElementById('placeStone');
                     if (placeBtn) {
                         placeBtn.addEventListener('click', function() {
                            // Client-side validation and immediate update without reload
                            const valid = updatePlaceStoneDisabled(selectedX, selectedY);
                            if (!valid) return;
                            if (!currentPlayer) return;

                            // Evolve statuses in local region (pre-placement)
                            evolveStatusesAround(selectedX, selectedY);
                            // Place stone locally
                            const nowTs = Date.now() / 1000;
                            setStoneAt(selectedX, selectedY, {
                                player_name: currentPlayer,
                                player_score: playerScores.get(currentPlayer) ?? 0, // provisional; will update below
                                status: 'Locked',
                                placement_time: nowTs,
                                last_status_change_time: nowTs
                            });
                            // New locked stone is not pending
                            if (PendingStonesIndex.has(selectedX, selectedY)) PendingStonesIndex.remove(selectedX, selectedY);

                            // Update scores for placement
                            updateUserScoreBy(1);
                            // Ensure the new stone carries updated score
                            const curScore = playerScores.get(currentPlayer) ?? 0;
                            const placed = getStoneAt(selectedX, selectedY);
                            if (placed) placed["player_score"] = curScore;

                            // Resolve captures locally
                            const cap = resolveCapturesAfterPlacement(selectedX, selectedY);
                            // Apply captured opponent deltas
                            if (cap.removedByPlayer && cap.removedByPlayer.size > 0) {
                                cap.removedByPlayer.forEach((cnt, pname) => {
                                    updatePlayerScore(pname, -cnt);
                                });
                            }
                            // Apply suicide net delta (if any)
                            if (cap.suicideRemoved > 0) {
                                updateUserScoreBy(-cap.suicideRemoved);
                            }
                            // Re-run disabled state, pending countdown, and leaderboard
                            updatePlaceStoneDisabled(selectedX, selectedY);
                            updatePendingCountdown(selectedX, selectedY);
                            rebuildLeaderboard(selectedX, selectedY);

                            // Persist on server in background
                            fetch(`/go-json?x=${selectedX}&y=${selectedY}`)
                                .then(r => r.json())
                                .then(resp => {
                                    if (!resp.success) {
                                        // Rollback: best-effort (refresh recommended on error)
                                        console.warn('Server rejected move:', resp.error);
                                    }
                                })
                                .catch(err => console.warn('Place stone network error', err));
                         });
                     }
                     const cycleBtn = document.getElementById('cyclePending');
                     if (cycleBtn) {
                         cycleBtn.addEventListener('click', function() {
                             // Compute next pending selection for current player without reload
                             if (!currentPlayer) return;
                             const pending = [];
                             Object.keys(stonesData).forEach((key) => {
                                 const s = stonesData[key];
                                 if (s["player_name"] === currentPlayer && s["status"] === 'Pending') {
                                     const parts = key.split(' ');
                                     pending.push({
                                         x: parseInt(parts[0], 10),
                                         y: parseInt(parts[1], 10),
                                         since: Number(s["last_status_change_time"]) || 0
                                     });
                                 }
                             });
                             // Also consult the PendingStonesIndex to ensure coverage
                             PendingStonesIndex.forEach(({x,y,since}) => {
                                 const k = `${x} ${y}`;
                                 const s = stonesData[k];
                                 if (s && s.player_name === currentPlayer && s.status === 'Pending') {
                                     pending.push({ x, y, since });
                                 }
                             });
                             if (pending.length === 0) {
                                 // No pending stones; keep selection
                                 return;
                             }
                             // Determine base time from current selection if it's your pending
                             let base = 0;
                             const curKey = `${selectedX} ${selectedY}`;
                             const curStone = stonesData[curKey];
                             if (curStone && curStone["player_name"] === currentPlayer && curStone["status"] === 'Pending') {
                                 base = Number(curStone["last_status_change_time"]) || 0;
                             }
                             const younger = pending.filter(p => p.since > base).sort((a,b)=>a.since-b.since);
                             let next;
                             if (younger.length > 0) {
                                 next = younger[0];
                             } else {
                                 // Oldest overall
                                 next = pending.sort((a,b)=>a.since-b.since)[0];
                             }
                             // Only pan if the selected position actually changes
const prevX = selectedX; const prevY = selectedY;
applySelection(next.x, next.y);
if ((prevX !== next.x || prevY !== next.y)) {
    if (typeof centerAndResetZoom === 'function') {
        centerAndResetZoom(next.x, next.y);
    } else if (typeof centerOnWorldCoord === 'function') {
        centerOnWorldCoord(next.x, next.y);
    }
}
});
                     }
                 })();

                  // One-second timer: auto-unlock pending stones and refresh UI/tooltip
                  (function startPendingUnlockTimer(){
                      function tryUnlockPending() {
                          const now = Date.now() / 1000;
                          // Gather keys to update after iteration
                          const toUnlock = [];
                          PendingStonesIndex.forEach(({x,y,since}) => {
                              if (since + 86400 <= now) {
                                  toUnlock.push([x,y]);
                              }
                          });
                          if (toUnlock.length > 0) {
                              for (let i=0;i<toUnlock.length;i++) {
                                  const [ux, uy] = toUnlock[i];
                                  const k = `${ux} ${uy}`;
                                  const s = stonesData[k];
                                  if (s && s.status === 'Pending') {
                                      s.status = 'Unlocked';
                                      s.last_status_change_time = now;
                                      stonesData[k] = s;
                                  }
                                  PendingStonesIndex.remove(ux, uy);
                              }
                              // Ensure any selection-dependent UI updates
                              updatePlaceStoneDisabled(selectedX, selectedY);
                              updatePendingCountdown(selectedX, selectedY);
                              rebuildLeaderboard(selectedX, selectedY);
                          }
                          // Refresh tooltip countdown while hovering a pending stone
                          if (typeof window.refreshHoverTooltipNow === 'function') {
                              window.refreshHoverTooltipNow();
                          }
                      }
                      setInterval(tryUnlockPending, 1000);
                  })();
             </script>
    </body>
</html>